{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=void 0;var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _State=require(\"../../State\");var _interfaces=require(\"../interfaces\");var _PointerTracker=_interopRequireDefault(require(\"./PointerTracker\"));var _utils=require(\"../utils\");function _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}var GestureHandlerOrchestrator=exports.default=function(){function GestureHandlerOrchestrator(){(0,_classCallCheck2.default)(this,GestureHandlerOrchestrator);_defineProperty(this,\"gestureHandlers\",[]);_defineProperty(this,\"awaitingHandlers\",[]);_defineProperty(this,\"handlersToCancel\",[]);_defineProperty(this,\"handlingChangeSemaphore\",0);_defineProperty(this,\"activationIndex\",0);}(0,_createClass2.default)(GestureHandlerOrchestrator,[{key:\"scheduleFinishedHandlersCleanup\",value:function scheduleFinishedHandlersCleanup(){if(this.handlingChangeSemaphore===0){this.cleanupFinishedHandlers();}}},{key:\"cleanHandler\",value:function cleanHandler(handler){handler.reset();handler.setActive(false);handler.setAwaiting(false);handler.setActivationIndex(Number.MAX_VALUE);}},{key:\"removeHandlerFromOrchestrator\",value:function removeHandlerFromOrchestrator(handler){this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler),1);this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler),1);this.handlersToCancel.splice(this.handlersToCancel.indexOf(handler),1);}},{key:\"cleanupFinishedHandlers\",value:function cleanupFinishedHandlers(){for(var i=this.gestureHandlers.length-1;i>=0;--i){var handler=this.gestureHandlers[i];if(!handler){continue;}if(this.isFinished(handler.getState())&&!handler.isAwaiting()){this.gestureHandlers.splice(i,1);this.cleanHandler(handler);}}}},{key:\"hasOtherHandlerToWaitFor\",value:function hasOtherHandlerToWaitFor(handler){var _this=this;var hasToWait=false;this.gestureHandlers.forEach(function(otherHandler){if(otherHandler&&!_this.isFinished(otherHandler.getState())&&_this.shouldHandlerWaitForOther(handler,otherHandler)){hasToWait=true;return;}});return hasToWait;}},{key:\"tryActivate\",value:function tryActivate(handler){if(this.hasOtherHandlerToWaitFor(handler)){this.addAwaitingHandler(handler);}else if(handler.getState()!==_State.State.CANCELLED&&handler.getState()!==_State.State.FAILED){if(this.shouldActivate(handler)){this.makeActive(handler);}else{switch(handler.getState()){case _State.State.ACTIVE:handler.fail();break;case _State.State.BEGAN:handler.cancel();}}}}},{key:\"shouldActivate\",value:function shouldActivate(handler){for(var _iterator=_createForOfIteratorHelperLoose(this.gestureHandlers),_step;!(_step=_iterator()).done;){var otherHandler=_step.value;if(this.shouldHandlerBeCancelledBy(handler,otherHandler)){return false;}}return true;}},{key:\"cleanupAwaitingHandlers\",value:function cleanupAwaitingHandlers(handler){for(var i=0;i<this.awaitingHandlers.length;++i){if(!this.awaitingHandlers[i].isAwaiting()&&this.shouldHandlerWaitForOther(this.awaitingHandlers[i],handler)){this.cleanHandler(this.awaitingHandlers[i]);this.awaitingHandlers.splice(i,1);}}}},{key:\"onHandlerStateChange\",value:function onHandlerStateChange(handler,newState,oldState,sendIfDisabled){var _this2=this;if(!handler.isEnabled()&&!sendIfDisabled){return;}this.handlingChangeSemaphore+=1;if(this.isFinished(newState)){this.awaitingHandlers.forEach(function(otherHandler){if(_this2.shouldHandlerWaitForOther(otherHandler,handler)){if(newState===_State.State.END){otherHandler===null||otherHandler===void 0?void 0:otherHandler.cancel();if(otherHandler.getState()===_State.State.END){otherHandler.sendEvent(_State.State.CANCELLED,_State.State.BEGAN);}otherHandler===null||otherHandler===void 0?void 0:otherHandler.setAwaiting(false);}else{_this2.tryActivate(otherHandler);}}});}if(newState===_State.State.ACTIVE){this.tryActivate(handler);}else if(oldState===_State.State.ACTIVE||oldState===_State.State.END){if(handler.isActive()){handler.sendEvent(newState,oldState);}else if(oldState===_State.State.ACTIVE&&(newState===_State.State.CANCELLED||newState===_State.State.FAILED)){handler.sendEvent(newState,_State.State.BEGAN);}}else if(oldState!==_State.State.UNDETERMINED||newState!==_State.State.CANCELLED){handler.sendEvent(newState,oldState);}this.handlingChangeSemaphore-=1;this.scheduleFinishedHandlersCleanup();if(this.awaitingHandlers.indexOf(handler)<0){this.cleanupAwaitingHandlers(handler);}}},{key:\"makeActive\",value:function makeActive(handler){var _this3=this;var currentState=handler.getState();handler.setActive(true);handler.setShouldResetProgress(true);handler.setActivationIndex(this.activationIndex++);this.gestureHandlers.forEach(function(otherHandler){if(_this3.shouldHandlerBeCancelledBy(otherHandler,handler)){_this3.handlersToCancel.push(otherHandler);}});for(var i=this.handlersToCancel.length-1;i>=0;--i){var _this$handlersToCance;(_this$handlersToCance=this.handlersToCancel[i])===null||_this$handlersToCance===void 0?void 0:_this$handlersToCance.cancel();}this.awaitingHandlers.forEach(function(otherHandler){if(_this3.shouldHandlerBeCancelledBy(otherHandler,handler)){otherHandler===null||otherHandler===void 0?void 0:otherHandler.cancel();otherHandler===null||otherHandler===void 0?void 0:otherHandler.setAwaiting(true);}});handler.sendEvent(_State.State.ACTIVE,_State.State.BEGAN);if(currentState!==_State.State.ACTIVE){handler.sendEvent(_State.State.END,_State.State.ACTIVE);if(currentState!==_State.State.END){handler.sendEvent(_State.State.UNDETERMINED,_State.State.END);}}if(handler.isAwaiting()){handler.setAwaiting(false);for(var _i=0;_i<this.awaitingHandlers.length;++_i){if(this.awaitingHandlers[_i]===handler){this.awaitingHandlers.splice(_i,1);}}}this.handlersToCancel=[];}},{key:\"addAwaitingHandler\",value:function addAwaitingHandler(handler){var alreadyExists=false;this.awaitingHandlers.forEach(function(otherHandler){if(otherHandler===handler){alreadyExists=true;return;}});if(alreadyExists){return;}this.awaitingHandlers.push(handler);handler.setAwaiting(true);handler.setActivationIndex(this.activationIndex++);}},{key:\"recordHandlerIfNotPresent\",value:function recordHandlerIfNotPresent(handler){var alreadyExists=false;this.gestureHandlers.forEach(function(otherHandler){if(otherHandler===handler){alreadyExists=true;return;}});if(alreadyExists){return;}this.gestureHandlers.push(handler);handler.setActive(false);handler.setAwaiting(false);handler.setActivationIndex(Number.MAX_SAFE_INTEGER);}},{key:\"shouldHandlerWaitForOther\",value:function shouldHandlerWaitForOther(handler,otherHandler){return handler!==otherHandler&&(handler.shouldWaitForHandlerFailure(otherHandler)||otherHandler.shouldRequireToWaitForFailure(handler));}},{key:\"canRunSimultaneously\",value:function canRunSimultaneously(gh1,gh2){return gh1===gh2||gh1.shouldRecognizeSimultaneously(gh2)||gh2.shouldRecognizeSimultaneously(gh1);}},{key:\"shouldHandlerBeCancelledBy\",value:function shouldHandlerBeCancelledBy(handler,otherHandler){if(this.canRunSimultaneously(handler,otherHandler)){return false;}if(handler!==otherHandler&&(handler.isAwaiting()||handler.getState()===_State.State.ACTIVE)){return handler.shouldBeCancelledByOther(otherHandler);}var handlerPointers=handler.getTrackedPointersID();var otherPointers=otherHandler.getTrackedPointersID();if(!_PointerTracker.default.shareCommonPointers(handlerPointers,otherPointers)&&handler.getView()!==otherHandler.getView()){return this.checkOverlap(handler,otherHandler);}return true;}},{key:\"checkOverlap\",value:function checkOverlap(handler,otherHandler){var handlerPointers=handler.getTrackedPointersID();var otherPointers=otherHandler.getTrackedPointersID();var overlap=false;handlerPointers.forEach(function(pointer){var handlerX=handler.getTracker().getLastX(pointer);var handlerY=handler.getTracker().getLastY(pointer);if((0,_utils.isPointerInBounds)(handler.getView(),{x:handlerX,y:handlerY})&&(0,_utils.isPointerInBounds)(otherHandler.getView(),{x:handlerX,y:handlerY})){overlap=true;}});otherPointers.forEach(function(pointer){var otherX=otherHandler.getTracker().getLastX(pointer);var otherY=otherHandler.getTracker().getLastY(pointer);if((0,_utils.isPointerInBounds)(handler.getView(),{x:otherX,y:otherY})&&(0,_utils.isPointerInBounds)(otherHandler.getView(),{x:otherX,y:otherY})){overlap=true;}});return overlap;}},{key:\"isFinished\",value:function isFinished(state){return state===_State.State.END||state===_State.State.FAILED||state===_State.State.CANCELLED;}},{key:\"cancelMouseAndPenGestures\",value:function cancelMouseAndPenGestures(currentHandler){this.gestureHandlers.forEach(function(handler){if(handler.getPointerType()!==_interfaces.PointerType.MOUSE&&handler.getPointerType()!==_interfaces.PointerType.PEN){return;}if(handler!==currentHandler){handler.cancel();}else{handler.getTracker().resetTracker();}});}}],[{key:\"getInstance\",value:function getInstance(){if(!GestureHandlerOrchestrator.instance){GestureHandlerOrchestrator.instance=new GestureHandlerOrchestrator();}return GestureHandlerOrchestrator.instance;}}]);return GestureHandlerOrchestrator;}();_defineProperty(GestureHandlerOrchestrator,\"instance\",void 0);","map":{"version":3,"names":["_State","require","_interfaces","_PointerTracker","_interopRequireDefault","_utils","_createForOfIteratorHelperLoose","o","allowArrayLike","it","Symbol","iterator","call","next","bind","Array","isArray","_unsupportedIterableToArray","length","i","done","value","TypeError","minLen","_arrayLikeToArray","n","Object","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","GestureHandlerOrchestrator","exports","default","_classCallCheck2","_defineProperty","_createClass2","key","scheduleFinishedHandlersCleanup","handlingChangeSemaphore","cleanupFinishedHandlers","cleanHandler","handler","reset","setActive","setAwaiting","setActivationIndex","Number","MAX_VALUE","removeHandlerFromOrchestrator","gestureHandlers","splice","indexOf","awaitingHandlers","handlersToCancel","isFinished","getState","isAwaiting","hasOtherHandlerToWaitFor","_this","hasToWait","forEach","otherHandler","shouldHandlerWaitForOther","tryActivate","addAwaitingHandler","State","CANCELLED","FAILED","shouldActivate","makeActive","ACTIVE","fail","BEGAN","cancel","_iterator","_step","shouldHandlerBeCancelledBy","cleanupAwaitingHandlers","onHandlerStateChange","newState","oldState","sendIfDisabled","_this2","isEnabled","END","sendEvent","isActive","UNDETERMINED","_this3","currentState","setShouldResetProgress","activationIndex","push","_this$handlersToCance","alreadyExists","recordHandlerIfNotPresent","MAX_SAFE_INTEGER","shouldWaitForHandlerFailure","shouldRequireToWaitForFailure","canRunSimultaneously","gh1","gh2","shouldRecognizeSimultaneously","shouldBeCancelledByOther","handlerPointers","getTrackedPointersID","otherPointers","PointerTracker","shareCommonPointers","getView","checkOverlap","overlap","pointer","handlerX","getTracker","getLastX","handlerY","getLastY","isPointerInBounds","x","y","otherX","otherY","state","cancelMouseAndPenGestures","currentHandler","getPointerType","PointerType","MOUSE","PEN","resetTracker","getInstance","instance"],"sources":["/Users/shayan/workspace/godfather/node_modules/react-native-gesture-handler/lib/module/web/tools/GestureHandlerOrchestrator.ts"],"sourcesContent":["import { State } from '../../State';\nimport { PointerType } from '../interfaces';\n\nimport GestureHandler from '../handlers/GestureHandler';\nimport PointerTracker from './PointerTracker';\nimport { isPointerInBounds } from '../utils';\n\nexport default class GestureHandlerOrchestrator {\n  private static instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: GestureHandler[] = [];\n  private awaitingHandlers: GestureHandler[] = [];\n  private handlersToCancel: GestureHandler[] = [];\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: GestureHandler): void {\n    handler.reset();\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_VALUE);\n  }\n\n  public removeHandlerFromOrchestrator(handler: GestureHandler): void {\n    this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);\n    this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);\n    this.handlersToCancel.splice(this.handlersToCancel.indexOf(handler), 1);\n  }\n\n  private cleanupFinishedHandlers(): void {\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n\n      if (!handler) {\n        continue;\n      }\n      if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n        this.gestureHandlers.splice(i, 1);\n\n        this.cleanHandler(handler);\n      }\n    }\n  }\n\n  private hasOtherHandlerToWaitFor(handler: GestureHandler): boolean {\n    let hasToWait = false;\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (\n        otherHandler &&\n        !this.isFinished(otherHandler.getState()) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      ) {\n        hasToWait = true;\n        return;\n      }\n    });\n\n    return hasToWait;\n  }\n\n  private tryActivate(handler: GestureHandler): void {\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n    } else if (\n      handler.getState() !== State.CANCELLED &&\n      handler.getState() !== State.FAILED\n    ) {\n      if (this.shouldActivate(handler)) {\n        this.makeActive(handler);\n      } else {\n        switch (handler.getState()) {\n          case State.ACTIVE:\n            handler.fail();\n            break;\n          case State.BEGAN:\n            handler.cancel();\n        }\n      }\n    }\n  }\n\n  private shouldActivate(handler: GestureHandler): boolean {\n    for (const otherHandler of this.gestureHandlers) {\n      if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private cleanupAwaitingHandlers(handler: GestureHandler): void {\n    for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n      if (\n        !this.awaitingHandlers[i].isAwaiting() &&\n        this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)\n      ) {\n        this.cleanHandler(this.awaitingHandlers[i]);\n        this.awaitingHandlers.splice(i, 1);\n      }\n    }\n  }\n\n  public onHandlerStateChange(\n    handler: GestureHandler,\n    newState: State,\n    oldState: State,\n    sendIfDisabled?: boolean\n  ): void {\n    if (!handler.isEnabled() && !sendIfDisabled) {\n      return;\n    }\n\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      this.awaitingHandlers.forEach((otherHandler) => {\n        if (this.shouldHandlerWaitForOther(otherHandler, handler)) {\n          if (newState === State.END) {\n            otherHandler?.cancel();\n            if (otherHandler.getState() === State.END) {\n              // Handle edge case, where discrete gestures end immediately after activation thus\n              // their state is set to END and when the gesture they are waiting for activates they\n              // should be cancelled, however `cancel` was never sent as gestures were already in the END state.\n              // Send synthetic BEGAN -> CANCELLED to properly handle JS logic\n              otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n            }\n            otherHandler?.setAwaiting(false);\n          } else {\n            this.tryActivate(otherHandler);\n          }\n        }\n      });\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.isActive()) {\n        handler.sendEvent(newState, oldState);\n      } else if (\n        oldState === State.ACTIVE &&\n        (newState === State.CANCELLED || newState === State.FAILED)\n      ) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (this.awaitingHandlers.indexOf(handler) < 0) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(handler: GestureHandler): void {\n    const currentState = handler.getState();\n\n    handler.setActive(true);\n    handler.setShouldResetProgress(true);\n    handler.setActivationIndex(this.activationIndex++);\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      // Order of arguments is correct - we check whether current handler should cancel existing handlers\n\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        this.handlersToCancel.push(otherHandler);\n      }\n    });\n\n    for (let i = this.handlersToCancel.length - 1; i >= 0; --i) {\n      this.handlersToCancel[i]?.cancel();\n    }\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler?.cancel();\n        otherHandler?.setAwaiting(true);\n      }\n    });\n\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (handler.isAwaiting()) {\n      handler.setAwaiting(false);\n      for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n        if (this.awaitingHandlers[i] === handler) {\n          this.awaitingHandlers.splice(i, 1);\n        }\n      }\n    }\n\n    this.handlersToCancel = [];\n  }\n\n  private addAwaitingHandler(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n\n    handler.setAwaiting(true);\n    handler.setActivationIndex(this.activationIndex++);\n  }\n\n  public recordHandlerIfNotPresent(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: GestureHandler,\n    gh2: GestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (\n      handler !== otherHandler &&\n      (handler.isAwaiting() || handler.getState() === State.ACTIVE)\n    ) {\n      // For now it always returns false\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.getView() !== otherHandler.getView()\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    let overlap = false;\n\n    handlerPointers.forEach((pointer: number) => {\n      const handlerX: number = handler.getTracker().getLastX(pointer);\n      const handlerY: number = handler.getTracker().getLastY(pointer);\n\n      if (\n        isPointerInBounds(handler.getView(), { x: handlerX, y: handlerY }) &&\n        isPointerInBounds(otherHandler.getView(), { x: handlerX, y: handlerY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    otherPointers.forEach((pointer: number) => {\n      const otherX: number = otherHandler.getTracker().getLastX(pointer);\n      const otherY: number = otherHandler.getTracker().getLastY(pointer);\n\n      if (\n        isPointerInBounds(handler.getView(), { x: otherX, y: otherY }) &&\n        isPointerInBounds(otherHandler.getView(), { x: otherX, y: otherY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    return overlap;\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  // This function is called when handler receives touchdown event\n  // If handler is using mouse or pen as a pointer and any handler receives touch event,\n  // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)\n  // This became a problem because handler was left at active state without any signal to end or fail\n  // To handle this, when new touch event is received, we loop through active handlers and check which type of\n  // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them\n  public cancelMouseAndPenGestures(currentHandler: GestureHandler): void {\n    this.gestureHandlers.forEach((handler: GestureHandler) => {\n      if (\n        handler.getPointerType() !== PointerType.MOUSE &&\n        handler.getPointerType() !== PointerType.PEN\n      ) {\n        return;\n      }\n\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        // Handler that received touch event should have its pointer tracker reset\n        // This allows handler to smoothly change from mouse/pen to touch\n        // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time\n        // so it is required to click two times to get handler to work\n        //\n        // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.\n        // There may be possibility to use that fact to make handler respond properly to first mouse click\n        handler.getTracker().resetTracker();\n      }\n    });\n  }\n\n  public static getInstance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator.instance) {\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n    }\n\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}