{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.CellRenderMask=void 0;var _toConsumableArray2=_interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _objectSpread2=_interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));var _invariant=_interopRequireDefault(require(\"fbjs/lib/invariant\"));var CellRenderMask=exports.CellRenderMask=function(){function CellRenderMask(numCells){(0,_classCallCheck2.default)(this,CellRenderMask);(0,_invariant.default)(numCells>=0,'CellRenderMask must contain a non-negative number os cells');this._numCells=numCells;if(numCells===0){this._regions=[];}else{this._regions=[{first:0,last:numCells-1,isSpacer:true}];}}(0,_createClass2.default)(CellRenderMask,[{key:\"enumerateRegions\",value:function enumerateRegions(){return this._regions;}},{key:\"addCells\",value:function addCells(cells){var _this$_regions;(0,_invariant.default)(cells.first>=0&&cells.first<this._numCells&&cells.last>=-1&&cells.last<this._numCells&&cells.last>=cells.first-1,'CellRenderMask.addCells called with invalid cell range');if(cells.last<cells.first){return;}var _this$_findRegion=this._findRegion(cells.first),firstIntersect=_this$_findRegion[0],firstIntersectIdx=_this$_findRegion[1];var _this$_findRegion2=this._findRegion(cells.last),lastIntersect=_this$_findRegion2[0],lastIntersectIdx=_this$_findRegion2[1];if(firstIntersectIdx===lastIntersectIdx&&!firstIntersect.isSpacer){return;}var newLeadRegion=[];var newTailRegion=[];var newMainRegion=(0,_objectSpread2.default)((0,_objectSpread2.default)({},cells),{},{isSpacer:false});if(firstIntersect.first<newMainRegion.first){if(firstIntersect.isSpacer){newLeadRegion.push({first:firstIntersect.first,last:newMainRegion.first-1,isSpacer:true});}else{newMainRegion.first=firstIntersect.first;}}if(lastIntersect.last>newMainRegion.last){if(lastIntersect.isSpacer){newTailRegion.push({first:newMainRegion.last+1,last:lastIntersect.last,isSpacer:true});}else{newMainRegion.last=lastIntersect.last;}}var replacementRegions=[].concat(newLeadRegion,[newMainRegion],newTailRegion);var numRegionsToDelete=lastIntersectIdx-firstIntersectIdx+1;(_this$_regions=this._regions).splice.apply(_this$_regions,[firstIntersectIdx,numRegionsToDelete].concat((0,_toConsumableArray2.default)(replacementRegions)));}},{key:\"numCells\",value:function numCells(){return this._numCells;}},{key:\"equals\",value:function equals(other){return this._numCells===other._numCells&&this._regions.length===other._regions.length&&this._regions.every(function(region,i){return region.first===other._regions[i].first&&region.last===other._regions[i].last&&region.isSpacer===other._regions[i].isSpacer;});}},{key:\"_findRegion\",value:function _findRegion(cellIdx){var firstIdx=0;var lastIdx=this._regions.length-1;while(firstIdx<=lastIdx){var middleIdx=Math.floor((firstIdx+lastIdx)/2);var middleRegion=this._regions[middleIdx];if(cellIdx>=middleRegion.first&&cellIdx<=middleRegion.last){return[middleRegion,middleIdx];}else if(cellIdx<middleRegion.first){lastIdx=middleIdx-1;}else if(cellIdx>middleRegion.last){firstIdx=middleIdx+1;}}(0,_invariant.default)(false,\"A region was not found containing cellIdx \"+cellIdx);}}]);return CellRenderMask;}();","map":{"version":3,"names":["_objectSpread2","_interopRequireDefault","require","_invariant","CellRenderMask","exports","numCells","_classCallCheck2","default","invariant","_numCells","_regions","first","last","isSpacer","_createClass2","key","value","enumerateRegions","addCells","cells","_this$_regions","_this$_findRegion","_findRegion","firstIntersect","firstIntersectIdx","_this$_findRegion2","lastIntersect","lastIntersectIdx","newLeadRegion","newTailRegion","newMainRegion","_objectSpread","push","replacementRegions","concat","numRegionsToDelete","splice","apply","_toConsumableArray2","equals","other","length","every","region","i","cellIdx","firstIdx","lastIdx","middleIdx","Math","floor","middleRegion"],"sources":["/Users/shayan/workspace/godfather/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/CellRenderMask.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n\nimport invariant from 'fbjs/lib/invariant';\nexport class CellRenderMask {\n  constructor(numCells) {\n    invariant(numCells >= 0, 'CellRenderMask must contain a non-negative number os cells');\n    this._numCells = numCells;\n    if (numCells === 0) {\n      this._regions = [];\n    } else {\n      this._regions = [{\n        first: 0,\n        last: numCells - 1,\n        isSpacer: true\n      }];\n    }\n  }\n  enumerateRegions() {\n    return this._regions;\n  }\n  addCells(cells) {\n    invariant(cells.first >= 0 && cells.first < this._numCells && cells.last >= -1 && cells.last < this._numCells && cells.last >= cells.first - 1, 'CellRenderMask.addCells called with invalid cell range');\n\n    // VirtualizedList uses inclusive ranges, where zero-count states are\n    // possible. E.g. [0, -1] for no cells, starting at 0.\n    if (cells.last < cells.first) {\n      return;\n    }\n    var _this$_findRegion = this._findRegion(cells.first),\n      firstIntersect = _this$_findRegion[0],\n      firstIntersectIdx = _this$_findRegion[1];\n    var _this$_findRegion2 = this._findRegion(cells.last),\n      lastIntersect = _this$_findRegion2[0],\n      lastIntersectIdx = _this$_findRegion2[1];\n\n    // Fast-path if the cells to add are already all present in the mask. We\n    // will otherwise need to do some mutation.\n    if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {\n      return;\n    }\n\n    // We need to replace the existing covered regions with 1-3 new regions\n    // depending whether we need to split spacers out of overlapping regions.\n    var newLeadRegion = [];\n    var newTailRegion = [];\n    var newMainRegion = _objectSpread(_objectSpread({}, cells), {}, {\n      isSpacer: false\n    });\n    if (firstIntersect.first < newMainRegion.first) {\n      if (firstIntersect.isSpacer) {\n        newLeadRegion.push({\n          first: firstIntersect.first,\n          last: newMainRegion.first - 1,\n          isSpacer: true\n        });\n      } else {\n        newMainRegion.first = firstIntersect.first;\n      }\n    }\n    if (lastIntersect.last > newMainRegion.last) {\n      if (lastIntersect.isSpacer) {\n        newTailRegion.push({\n          first: newMainRegion.last + 1,\n          last: lastIntersect.last,\n          isSpacer: true\n        });\n      } else {\n        newMainRegion.last = lastIntersect.last;\n      }\n    }\n    var replacementRegions = [...newLeadRegion, newMainRegion, ...newTailRegion];\n    var numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;\n    this._regions.splice(firstIntersectIdx, numRegionsToDelete, ...replacementRegions);\n  }\n  numCells() {\n    return this._numCells;\n  }\n  equals(other) {\n    return this._numCells === other._numCells && this._regions.length === other._regions.length && this._regions.every((region, i) => region.first === other._regions[i].first && region.last === other._regions[i].last && region.isSpacer === other._regions[i].isSpacer);\n  }\n  _findRegion(cellIdx) {\n    var firstIdx = 0;\n    var lastIdx = this._regions.length - 1;\n    while (firstIdx <= lastIdx) {\n      var middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n      var middleRegion = this._regions[middleIdx];\n      if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {\n        return [middleRegion, middleIdx];\n      } else if (cellIdx < middleRegion.first) {\n        lastIdx = middleIdx - 1;\n      } else if (cellIdx > middleRegion.last) {\n        firstIdx = middleIdx + 1;\n      }\n    }\n    invariant(false, \"A region was not found containing cellIdx \" + cellIdx);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}