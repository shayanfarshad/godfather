{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=void 0;var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}var EventManager=exports.default=function(){function EventManager(view){(0,_classCallCheck2.default)(this,EventManager);_defineProperty(this,\"view\",void 0);_defineProperty(this,\"pointersInBounds\",[]);_defineProperty(this,\"activePointersCounter\",void 0);this.view=view;this.activePointersCounter=0;}(0,_createClass2.default)(EventManager,[{key:\"onPointerDown\",value:function onPointerDown(_event){}},{key:\"onPointerAdd\",value:function onPointerAdd(_event){}},{key:\"onPointerUp\",value:function onPointerUp(_event){}},{key:\"onPointerRemove\",value:function onPointerRemove(_event){}},{key:\"onPointerMove\",value:function onPointerMove(_event){}},{key:\"onPointerLeave\",value:function onPointerLeave(_event){}},{key:\"onPointerEnter\",value:function onPointerEnter(_event){}},{key:\"onPointerCancel\",value:function onPointerCancel(_event){}},{key:\"onPointerOutOfBounds\",value:function onPointerOutOfBounds(_event){}},{key:\"onPointerMoveOver\",value:function onPointerMoveOver(_event){}},{key:\"onPointerMoveOut\",value:function onPointerMoveOut(_event){}},{key:\"setOnPointerDown\",value:function setOnPointerDown(callback){this.onPointerDown=callback;}},{key:\"setOnPointerAdd\",value:function setOnPointerAdd(callback){this.onPointerAdd=callback;}},{key:\"setOnPointerUp\",value:function setOnPointerUp(callback){this.onPointerUp=callback;}},{key:\"setOnPointerRemove\",value:function setOnPointerRemove(callback){this.onPointerRemove=callback;}},{key:\"setOnPointerMove\",value:function setOnPointerMove(callback){this.onPointerMove=callback;}},{key:\"setOnPointerLeave\",value:function setOnPointerLeave(callback){this.onPointerLeave=callback;}},{key:\"setOnPointerEnter\",value:function setOnPointerEnter(callback){this.onPointerEnter=callback;}},{key:\"setOnPointerCancel\",value:function setOnPointerCancel(callback){this.onPointerCancel=callback;}},{key:\"setOnPointerOutOfBounds\",value:function setOnPointerOutOfBounds(callback){this.onPointerOutOfBounds=callback;}},{key:\"setOnPointerMoveOver\",value:function setOnPointerMoveOver(callback){this.onPointerMoveOver=callback;}},{key:\"setOnPointerMoveOut\",value:function setOnPointerMoveOut(callback){this.onPointerMoveOut=callback;}},{key:\"markAsInBounds\",value:function markAsInBounds(pointerId){if(this.pointersInBounds.indexOf(pointerId)>=0){return;}this.pointersInBounds.push(pointerId);}},{key:\"markAsOutOfBounds\",value:function markAsOutOfBounds(pointerId){var index=this.pointersInBounds.indexOf(pointerId);if(index<0){return;}this.pointersInBounds.splice(index,1);}},{key:\"resetManager\",value:function resetManager(){this.activePointersCounter=0;this.pointersInBounds=[];}}]);return EventManager;}();","map":{"version":3,"names":["EventManager","exports","default","view","_classCallCheck2","_defineProperty","activePointersCounter","_createClass2","key","value","onPointerDown","_event","onPointerAdd","onPointerUp","onPointerRemove","onPointerMove","onPointerLeave","onPointerEnter","onPointerCancel","onPointerOutOfBounds","onPointerMoveOver","onPointerMoveOut","setOnPointerDown","callback","setOnPointerAdd","setOnPointerUp","setOnPointerRemove","setOnPointerMove","setOnPointerLeave","setOnPointerEnter","setOnPointerCancel","setOnPointerOutOfBounds","setOnPointerMoveOver","setOnPointerMoveOut","markAsInBounds","pointerId","pointersInBounds","indexOf","push","markAsOutOfBounds","index","splice","resetManager"],"sources":["/Users/shayan/workspace/godfather/node_modules/react-native-gesture-handler/lib/module/web/tools/EventManager.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-function */\nimport { AdaptedEvent, EventTypes, TouchEventType } from '../interfaces';\n\nexport default abstract class EventManager<T> {\n  protected readonly view: T;\n  protected pointersInBounds: number[] = [];\n  protected activePointersCounter: number;\n\n  constructor(view: T) {\n    this.view = view;\n    this.activePointersCounter = 0;\n  }\n\n  public abstract setListeners(): void;\n  protected abstract mapEvent(\n    event: Event,\n    eventType: EventTypes,\n    index?: number,\n    touchEventType?: TouchEventType\n  ): AdaptedEvent;\n\n  protected onPointerDown(_event: AdaptedEvent): void {}\n  protected onPointerAdd(_event: AdaptedEvent): void {}\n  protected onPointerUp(_event: AdaptedEvent): void {}\n  protected onPointerRemove(_event: AdaptedEvent): void {}\n  protected onPointerMove(_event: AdaptedEvent): void {}\n  protected onPointerLeave(_event: AdaptedEvent): void {} // called only when pointer is pressed (or touching)\n  protected onPointerEnter(_event: AdaptedEvent): void {} // called only when pointer is pressed (or touching)\n  protected onPointerCancel(_event: AdaptedEvent): void {\n    // When pointer cancel is triggered and there are more pointers on the view, only one pointer is cancelled\n    // Because we want all pointers to be cancelled by that event, we are doing it manually by reseting handler and changing activePointersCounter to 0\n    // Events that correspond to removing the pointer (pointerup, touchend) have condition, that they don't perform any action when activePointersCounter\n    // is equal to 0. This prevents counter from going to negative values, when pointers are removed from view after one of them has been cancelled\n  }\n  protected onPointerOutOfBounds(_event: AdaptedEvent): void {}\n  protected onPointerMoveOver(_event: AdaptedEvent): void {}\n  protected onPointerMoveOut(_event: AdaptedEvent): void {}\n\n  public setOnPointerDown(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerDown = callback;\n  }\n  public setOnPointerAdd(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerAdd = callback;\n  }\n  public setOnPointerUp(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerUp = callback;\n  }\n  public setOnPointerRemove(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerRemove = callback;\n  }\n  public setOnPointerMove(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerMove = callback;\n  }\n  public setOnPointerLeave(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerLeave = callback;\n  }\n  public setOnPointerEnter(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerEnter = callback;\n  }\n  public setOnPointerCancel(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerCancel = callback;\n  }\n  public setOnPointerOutOfBounds(\n    callback: (event: AdaptedEvent) => void\n  ): void {\n    this.onPointerOutOfBounds = callback;\n  }\n  public setOnPointerMoveOver(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerMoveOver = callback;\n  }\n  public setOnPointerMoveOut(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerMoveOut = callback;\n  }\n\n  protected markAsInBounds(pointerId: number): void {\n    if (this.pointersInBounds.indexOf(pointerId) >= 0) {\n      return;\n    }\n\n    this.pointersInBounds.push(pointerId);\n  }\n\n  protected markAsOutOfBounds(pointerId: number): void {\n    const index: number = this.pointersInBounds.indexOf(pointerId);\n\n    if (index < 0) {\n      return;\n    }\n\n    this.pointersInBounds.splice(index, 1);\n  }\n\n  public resetManager(): void {\n    // Reseting activePointersCounter is necessary to make gestures such as pinch work properly\n    // There are gestures that end when there is still one active pointer (like pinch/rotation)\n    // When these gestures end, they are reset, but they still receive events from pointer that is active\n    // This causes trouble, since only onPointerDown registers gesture in orchestrator, and while gestures receive\n    // Events from active pointer after they finished, next pointerdown event will be registered as additional pointer, not the first one\n    // This casues trouble like gestures getting stuck in END state, even though they should have gone to UNDETERMINED\n\n    this.activePointersCounter = 0;\n    this.pointersInBounds = [];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}