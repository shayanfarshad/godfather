{"ast":null,"code":"Object.defineProperty(exports,\"__esModule\",{value:true});exports.createMapperRegistry=void 0;exports.startMapper=startMapper;exports.stopMapper=stopMapper;var _PlatformChecker=require(\"./PlatformChecker\");var _threads=require(\"./threads\");var _utils=require(\"./utils\");function _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2;}var IS_JEST=(0,_PlatformChecker.isJest)();var _worklet_4869237921139_init_data={code:\"function createMapperRegistry(){const{IS_JEST,isSharedValue}=this._closure;const mappers=new Map();let sortedMappers=[];let runRequested=false;let processingMappers=false;function updateMappersOrder(){const pre=new Map();mappers.forEach(function(mapper){if(mapper.outputs){for(const output of mapper.outputs){const preMappers=pre.get(output);if(preMappers===undefined){pre.set(output,[mapper]);}else{preMappers.push(mapper);}}}});const visited=new Set();const newOrder=[];function dfs(mapper){visited.add(mapper);for(const input of mapper.inputs){const preMappers=pre.get(input);if(preMappers){for(const preMapper of preMappers){if(!visited.has(preMapper)){dfs(preMapper);}}}}newOrder.push(mapper);}mappers.forEach(function(mapper){if(!visited.has(mapper)){dfs(mapper);}});sortedMappers=newOrder;}function mapperRun(){runRequested=false;if(processingMappers){return;}processingMappers=true;if(mappers.size!==sortedMappers.length){updateMappersOrder();}for(const mapper of sortedMappers){if(mapper.dirty){mapper.dirty=false;mapper.worklet();}}processingMappers=false;}function maybeRequestUpdates(){if(IS_JEST){mapperRun();}else if(!runRequested){if(processingMappers){requestAnimationFrame(mapperRun);}else{queueMicrotask(mapperRun);}runRequested=true;}}function extractInputs(inputs,resultArray){if(Array.isArray(inputs)){for(const input of inputs){input&&extractInputs(input,resultArray);}}else if(isSharedValue(inputs)){resultArray.push(inputs);}else if(Object.getPrototypeOf(inputs)===Object.prototype){for(const element of Object.values(inputs)){element&&extractInputs(element,resultArray);}}return resultArray;}return{start:function(mapperID,worklet,inputs,outputs){const mapper={id:mapperID,dirty:true,worklet:worklet,inputs:extractInputs(inputs,[]),outputs:outputs};mappers.set(mapper.id,mapper);sortedMappers=[];for(const sv of mapper.inputs){sv.addListener(mapper.id,function(){mapper.dirty=true;maybeRequestUpdates();});}maybeRequestUpdates();},stop:function(mapperID){const mapper=mappers.get(mapperID);if(mapper){mappers.delete(mapper.id);sortedMappers=[];for(const sv of mapper.inputs){sv.removeListener(mapper.id);}}}};}\",location:\"node_modules/react-native-reanimated/lib/module/reanimated2/mappers.js\"};var createMapperRegistry=exports.createMapperRegistry=function(){var _f=function _f(){var mappers=new Map();var sortedMappers=[];var runRequested=false;var processingMappers=false;function updateMappersOrder(){var pre=new Map();mappers.forEach(function(mapper){if(mapper.outputs){for(var _iterator=_createForOfIteratorHelperLoose(mapper.outputs),_step;!(_step=_iterator()).done;){var output=_step.value;var preMappers=pre.get(output);if(preMappers===undefined){pre.set(output,[mapper]);}else{preMappers.push(mapper);}}}});var visited=new Set();var newOrder=[];function dfs(mapper){visited.add(mapper);for(var _iterator2=_createForOfIteratorHelperLoose(mapper.inputs),_step2;!(_step2=_iterator2()).done;){var input=_step2.value;var preMappers=pre.get(input);if(preMappers){for(var _iterator3=_createForOfIteratorHelperLoose(preMappers),_step3;!(_step3=_iterator3()).done;){var preMapper=_step3.value;if(!visited.has(preMapper)){dfs(preMapper);}}}}newOrder.push(mapper);}mappers.forEach(function(mapper){if(!visited.has(mapper)){dfs(mapper);}});sortedMappers=newOrder;}function mapperRun(){runRequested=false;if(processingMappers){return;}processingMappers=true;if(mappers.size!==sortedMappers.length){updateMappersOrder();}for(var _iterator4=_createForOfIteratorHelperLoose(sortedMappers),_step4;!(_step4=_iterator4()).done;){var mapper=_step4.value;if(mapper.dirty){mapper.dirty=false;mapper.worklet();}}processingMappers=false;}function maybeRequestUpdates(){if(IS_JEST){mapperRun();}else if(!runRequested){if(processingMappers){requestAnimationFrame(mapperRun);}else{queueMicrotask(mapperRun);}runRequested=true;}}function extractInputs(inputs,resultArray){if(Array.isArray(inputs)){for(var _iterator5=_createForOfIteratorHelperLoose(inputs),_step5;!(_step5=_iterator5()).done;){var input=_step5.value;input&&extractInputs(input,resultArray);}}else if((0,_utils.isSharedValue)(inputs)){resultArray.push(inputs);}else if(Object.getPrototypeOf(inputs)===Object.prototype){for(var _i=0,_Object$values=Object.values(inputs);_i<_Object$values.length;_i++){var element=_Object$values[_i];element&&extractInputs(element,resultArray);}}return resultArray;}return{start:function start(mapperID,worklet,inputs,outputs){var mapper={id:mapperID,dirty:true,worklet:worklet,inputs:extractInputs(inputs,[]),outputs:outputs};mappers.set(mapper.id,mapper);sortedMappers=[];for(var _iterator6=_createForOfIteratorHelperLoose(mapper.inputs),_step6;!(_step6=_iterator6()).done;){var sv=_step6.value;sv.addListener(mapper.id,function(){mapper.dirty=true;maybeRequestUpdates();});}maybeRequestUpdates();},stop:function stop(mapperID){var mapper=mappers.get(mapperID);if(mapper){mappers.delete(mapper.id);sortedMappers=[];for(var _iterator7=_createForOfIteratorHelperLoose(mapper.inputs),_step7;!(_step7=_iterator7()).done;){var sv=_step7.value;sv.removeListener(mapper.id);}}}};};_f._closure={IS_JEST:IS_JEST,isSharedValue:_utils.isSharedValue};_f.__initData=_worklet_4869237921139_init_data;_f.__workletHash=4869237921139;return _f;}();var MAPPER_ID=9999;var _worklet_69439130052_init_data={code:\"function anonymous(){const{createMapperRegistry,mapperID,worklet,inputs,outputs}=this._closure;let mapperRegistry=global.__mapperRegistry;if(mapperRegistry===undefined){mapperRegistry=global.__mapperRegistry=createMapperRegistry();}mapperRegistry.start(mapperID,worklet,inputs,outputs);}\",location:\"node_modules/react-native-reanimated/lib/module/reanimated2/mappers.js\"};function startMapper(worklet){var inputs=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var outputs=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];var mapperID=MAPPER_ID+=1;(0,_threads.runOnUI)(function(){var _f=function _f(){var mapperRegistry=global.__mapperRegistry;if(mapperRegistry===undefined){mapperRegistry=global.__mapperRegistry=createMapperRegistry();}mapperRegistry.start(mapperID,worklet,inputs,outputs);};_f._closure={createMapperRegistry:createMapperRegistry,mapperID:mapperID,worklet:worklet,inputs:inputs,outputs:outputs};_f.__initData=_worklet_69439130052_init_data;_f.__workletHash=69439130052;return _f;}())();return mapperID;}var _worklet_14921975349672_init_data={code:\"function anonymous(){const{mapperID}=this._closure;const mapperRegistry=global.__mapperRegistry;mapperRegistry===null||mapperRegistry===void 0?void 0:mapperRegistry.stop(mapperID);}\",location:\"node_modules/react-native-reanimated/lib/module/reanimated2/mappers.js\"};function stopMapper(mapperID){(0,_threads.runOnUI)(function(){var _f=function _f(){var mapperRegistry=global.__mapperRegistry;mapperRegistry===null||mapperRegistry===void 0?void 0:mapperRegistry.stop(mapperID);};_f._closure={mapperID:mapperID};_f.__initData=_worklet_14921975349672_init_data;_f.__workletHash=14921975349672;return _f;}())();}","map":{"version":3,"names":["_PlatformChecker","require","_threads","_utils","_createForOfIteratorHelperLoose","o","allowArrayLike","it","Symbol","iterator","call","next","bind","Array","isArray","_unsupportedIterableToArray","length","i","done","value","TypeError","minLen","_arrayLikeToArray","n","Object","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","IS_JEST","isJest","_worklet_4869237921139_init_data","code","location","createMapperRegistry","exports","_f","mappers","Map","sortedMappers","runRequested","processingMappers","updateMappersOrder","pre","forEach","mapper","outputs","_iterator","_step","output","preMappers","get","undefined","set","push","visited","Set","newOrder","dfs","add","_iterator2","inputs","_step2","input","_iterator3","_step3","preMapper","has","mapperRun","size","_iterator4","_step4","dirty","worklet","maybeRequestUpdates","requestAnimationFrame","queueMicrotask","extractInputs","resultArray","_iterator5","_step5","isSharedValue","getPrototypeOf","_i","_Object$values","values","element","start","mapperID","id","_iterator6","_step6","sv","addListener","stop","delete","_iterator7","_step7","removeListener","_closure","__initData","__workletHash","MAPPER_ID","_worklet_69439130052_init_data","startMapper","arguments","runOnUI","mapperRegistry","global","__mapperRegistry","_worklet_14921975349672_init_data","stopMapper"],"sources":["/Users/shayan/workspace/godfather/node_modules/react-native-reanimated/lib/module/reanimated2/mappers.ts"],"sourcesContent":["import { SharedValue } from './commonTypes';\nimport { isJest } from './PlatformChecker';\nimport { runOnUI } from './threads';\nimport { isSharedValue } from './utils';\n\nconst IS_JEST = isJest();\n\nexport type Mapper = {\n  id: number;\n  dirty: boolean;\n  worklet: () => void;\n  inputs: SharedValue<any>[];\n  outputs?: SharedValue<any>[];\n};\n\nexport function createMapperRegistry() {\n  'worklet';\n  const mappers = new Map();\n  let sortedMappers: Mapper[] = [];\n\n  let runRequested = false;\n  let processingMappers = false;\n\n  function updateMappersOrder() {\n    // sort mappers topologically\n    // the algorithm here takes adventage of a fact that the topological order\n    // of a transposed graph is a reverse topological order of the original graph\n    // The graph in our case consists of mappers and an edge between two mappers\n    // A and B exists if there is a shared value that's on A's output lists and on\n    // B's input list.\n    //\n    // We don't need however to calculate that graph as it is easier to work with\n    // the transposed version of it that can be calculated ad-hoc. For the transposed\n    // version to be traversed we use \"pre\" map that maps share value to mappers that\n    // output that shared value. Then we can infer all the outgoing edges for a given\n    // mapper simply by scanning it's input list and checking if any of the shared values\n    // from that list exists in the \"pre\" map. If they do, then we have an edge between\n    // that mapper and the mappers from the \"pre\" list for the given shared value.\n    //\n    // For topological sorting we use a dfs-based approach that requires the graph to\n    // be traversed in dfs order and each node after being processed lands at the\n    // beginning of the topological order list. Since we traverse a transposed graph,\n    // instead of reversing that order we can use a normal array and push processed\n    // mappers to the end. There is no need to reverse that array after we are done.\n    const pre = new Map(); // map from sv -> mapper that outputs that sv\n    mappers.forEach((mapper) => {\n      if (mapper.outputs) {\n        for (const output of mapper.outputs) {\n          const preMappers = pre.get(output);\n          if (preMappers === undefined) {\n            pre.set(output, [mapper]);\n          } else {\n            preMappers.push(mapper);\n          }\n        }\n      }\n    });\n    const visited = new Set();\n    const newOrder: Mapper[] = [];\n    function dfs(mapper: Mapper) {\n      visited.add(mapper);\n      for (const input of mapper.inputs) {\n        const preMappers = pre.get(input);\n        if (preMappers) {\n          for (const preMapper of preMappers) {\n            if (!visited.has(preMapper)) {\n              dfs(preMapper);\n            }\n          }\n        }\n      }\n      newOrder.push(mapper);\n    }\n    mappers.forEach((mapper) => {\n      if (!visited.has(mapper)) {\n        dfs(mapper);\n      }\n    });\n    sortedMappers = newOrder;\n  }\n\n  function mapperRun() {\n    runRequested = false;\n    if (processingMappers) {\n      return;\n    }\n    processingMappers = true;\n    if (mappers.size !== sortedMappers.length) {\n      updateMappersOrder();\n    }\n    for (const mapper of sortedMappers) {\n      if (mapper.dirty) {\n        mapper.dirty = false;\n        mapper.worklet();\n      }\n    }\n    processingMappers = false;\n  }\n\n  function maybeRequestUpdates() {\n    if (IS_JEST) {\n      // On Jest environment we avoid using queueMicrotask as that'd require test\n      // to advance the clock manually. This on other hand would require tests\n      // to know how many times mappers need to run. As we don't want tests to\n      // make any assumptions on that number it is easier to execute mappers\n      // immediately for testing purposes and only expect test to advance timers\n      // if they want to make any assertions on the effects of animations being run.\n      mapperRun();\n    } else if (!runRequested) {\n      if (processingMappers) {\n        // In general, we should avoid having mappers trigger updates as this may\n        // result in unpredictable behavior. Specifically, the updated value can\n        // be read by mappers that run later in the same frame but previous mappers\n        // would access the old value. Updating mappers during the mapper-run phase\n        // breaks the order in which we should execute the mappers. However, doing\n        // that is still a possibility and there are some instances where people use\n        // the API in that way, hence we need to prevent mapper-run phase falling into\n        // an infinite loop. We do that by detecting when mapper-run is requested while\n        // we are already in mapper-run phase, and in that case we use `requestAnimationFrame`\n        // instead of `queueMicrotask` which will schedule mapper run for the next\n        // frame instead of queuing another set of updates in the same frame.\n        requestAnimationFrame(mapperRun);\n      } else {\n        queueMicrotask(mapperRun);\n      }\n      runRequested = true;\n    }\n  }\n\n  function extractInputs(\n    inputs: any,\n    resultArray: SharedValue<any>[]\n  ): SharedValue<any>[] {\n    if (Array.isArray(inputs)) {\n      for (const input of inputs) {\n        input && extractInputs(input, resultArray);\n      }\n    } else if (isSharedValue(inputs)) {\n      resultArray.push(inputs);\n    } else if (Object.getPrototypeOf(inputs) === Object.prototype) {\n      // we only extract inputs recursively from \"plain\" objects here, if object\n      // is of a derivative class (e.g. HostObject on web, or Map) we don't scan\n      // it recursively\n      for (const element of Object.values(inputs)) {\n        element && extractInputs(element, resultArray);\n      }\n    }\n    return resultArray;\n  }\n\n  return {\n    start: (\n      mapperID: number,\n      worklet: () => void,\n      inputs: SharedValue<any>[],\n      outputs?: SharedValue<any>[]\n    ) => {\n      const mapper = {\n        id: mapperID,\n        dirty: true,\n        worklet,\n        inputs: extractInputs(inputs, []),\n        outputs,\n      };\n      mappers.set(mapper.id, mapper);\n      sortedMappers = [];\n      for (const sv of mapper.inputs) {\n        sv.addListener(mapper.id, () => {\n          mapper.dirty = true;\n          maybeRequestUpdates();\n        });\n      }\n      maybeRequestUpdates();\n    },\n    stop: (mapperID: number) => {\n      const mapper = mappers.get(mapperID);\n      if (mapper) {\n        mappers.delete(mapper.id);\n        sortedMappers = [];\n        for (const sv of mapper.inputs) {\n          sv.removeListener(mapper.id);\n        }\n      }\n    },\n  };\n}\n\nlet MAPPER_ID = 9999;\n\nexport function startMapper(\n  worklet: () => void,\n  inputs: any[] = [],\n  outputs: any[] = []\n): number {\n  const mapperID = (MAPPER_ID += 1);\n\n  runOnUI(() => {\n    let mapperRegistry = global.__mapperRegistry;\n    if (mapperRegistry === undefined) {\n      mapperRegistry = global.__mapperRegistry = createMapperRegistry();\n    }\n    mapperRegistry.start(mapperID, worklet, inputs, outputs);\n  })();\n\n  return mapperID;\n}\n\nexport function stopMapper(mapperID: number): void {\n  runOnUI(() => {\n    const mapperRegistry = global.__mapperRegistry;\n    mapperRegistry?.stop(mapperID);\n  })();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}